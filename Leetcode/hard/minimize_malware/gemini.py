class Solution(object):
    def minMalwareSpread(self, graph, initial):
        """
        :type graph: List[List[int]]
        :type initial: List[int]
        :rtype: int
        """
        def dfs(graph, infected):
            """
            Performs a DFS traversal on the graph to identify infected devices.

            Args:
                graph: A 2D list representing the adjacency matrix of the network.
                infected: A list of indices representing the initially infected nodes.

            Returns:
                A list of indices representing all infected devices after the spread is contained.
            """
            visited = set()
            stack = list(infected) 

            while stack:
                node = stack.pop()
                if node in visited:
                    continue
                visited.add(node)
                for neighbor in range(len(graph)):
                    if graph[node][neighbor] and neighbor not in visited:
                        stack.append(neighbor)
            return visited

        infected_nodes = dfs(graph, initial)
        min_infected_count = len(infected_nodes)
        res = initial[0]

        for i in range(len(graph)):
            if i not in initial:
                new_graph = [row[0:] for row in graph]
                for j in range(len(graph)):
                    new_graph[i][j] = new_graph[j][i] = 0
                new_graph[i][i] = 0
                removed_infected_count = len(dfs(new_graph, infected_nodes))  # Use infected_nodes here
                if removed_infected_count < min_infected_count:
                    min_infected_count = removed_infected_count
                    res = i
        return res
        